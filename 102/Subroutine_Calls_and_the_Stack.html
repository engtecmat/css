<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Subroutine Calls and the Stack</title>
    <link href="https://fonts.googleapis.com/css?family=Kadwa" rel="stylesheet">
    <style>
        /* global variables */
        :root {
            --light-mode-background-color: #F0F4F8;
            --light-mode-h1-color: #191970;
            --light-mode-text-color: #191970;
        }

        body {
            font-family: "Kadwa", Georgia, "Times New Roman", Times, serif;
            line-height: 1.6;
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background-color: var(--light-mode-background-color);
        }

        p {
            white-space: pre-wrap;
            text-align: justify;
            font-size: 30px;
        }

        h1 {
            color: var(--light-mode-h1-color);
            font-size: 40px;
            text-align: center;
        }
    </style>
</head>
<body>
<h1>Subroutine Calls and the Stack</h1>
<p>
    Thank you. Okay, so today will be our last lecture on RAMP, So we're going to talk about how RAMP assembly language supports the subroutine course and also the stack memory. So those are actually the fundamental kind of stuff about low-level implementation of the method, Just to recap. so this is something we already talked about before the break. So we look at what is the architecture of computer system. So computer system, there are four main components: input devices, output devices and also memory units and also the CPU. And also look at instruction cycle. So that means once you have all your code transferred to machine code in the memory. so these are the kind of the machine code in the memory. each line is instruction, So O1, which is hexadecimal value. So those are the memory address. So this memory address, so that instruction. so the next memory address so that instructions and then how that instructions of a program has been executed. So so we also look at the kind of all these registers. so these are the registers. So inside CPU we have control unit that just coordinates all the operations between the memory and also the arithmetic or logic units And also we have storage. so storage are the registers. right? We look at general purpose registers. So those are the registers you can use as a programmer to load the data from memory to the register. And once you finish all the computation and save all data from the register to the memory, So any operation that is conducted by CPU has to through, has to go through the register You have load data to the register because you only have limited amount of registers, So you have to kind of this is just temporary storage. So once you finish the computation you have to move the data from stored in the register back to the memory. So, and then we look at some kind of special registers. The first, the most important one, is called program counter. So program counter always contains the memory address of the next instruction to be executed. So this is something I'd like you to remember. So program counter always contains the next, the memory address of the next instruction to be executed. So if your program is scheduled to be executed by CPU, so the program counter is going to contain the address of your program's first instruction. So this is the kind of how it started, right, When kind of operating system decided this is the time you're going to run your program and it's going to load the program to the memory And then it's going to assign the memory and then it's going to assign the memory address of your program's first instruction to the program counter. Okay, And then program counter. so what happens is next is so for each cycle, instruction cycle, so your CPU is going to look at your program counter, use that memory address, go to the kind of the computer memory to load the instruction. So this is kind of the fetch phase. So this is kind of the fetch phase, So fetch instruction from memory address or in program counter into the instruction register. So it's going to fetch that instruction to the instruction register and then decode. So that means once you're decoding, your program counter is going to point into the next instruction and then execute the instruction. So that kind of cycle finishes. And then now, because our program counter pointing to the next instruction, right while they're incremented, So next instruction is going to fetch into the register, instruction register. So this kind of cycle carries on after your program finishes. Now, if you look at that kind of list of instructions, right, stored in the memory address, stored in those kind of memory addresses, So from the point of view, from the CPU's point of view, actually, it has no idea what kind of the logic of your kind of instruction, whether it is kind of executing the for loop, whether it's doing the if-else, or it's just doing the kind of assignment or loading the data from that, From the memory, to the register, or saving the data from register to a memory. So it doesn't know, It's only follow the kind of next instruction, that kind of the next instruction that's using the address stored in the program counter. So, for example, so it's only will start right from 00 and next instruction will be a 102,, et cetera, until your program- So that's instruction- tells the kind of the. this is kind of the last instruction, Unless you do something: change the program counter, change the address stored in the program counter, And then the sequential of your instruction is going to be changed. So this is kind of if-else statement, right, and the for loop. So that means, if you just imagine, so you have a for loop over here, right, you go to the instruction three and then you change the address that's stored in the program counter to 01.. So let's go back to 01 again, Okay. So this is the kind of how you control the kind of flow of instruction is by changing the address, memory address that is stored in the program counter. So we're going to show you some examples. So I just want to kind of talk about it now to give you some ideas. Okay, How, how we change it right. So now let's just look at the, the ramp, the code, assembly code. So when we look at assembly code, we kind of talk about what are the means, right, What are these kind of the global main data, X and Y, and then means, So anything that starts with a dot like global or data. these are the directives, So they're just the parsing. These are not part of the machine code. So this is the actual machine code. If you look at machine code, there's no kind of global right, There's no data. So they just kind of the directives that are telling the information, they're telling the assembler some information. So this is a kind of the main method, right, This is a starting point of this program. So this of what's following is going to be the data. So it's just telling the assembler that where are you going to store the data, where is the entry point of your program? So, and then we have labels. Labels are very important, So labels. So you just have to remember labels itself is just referred to a location in the memory. Okay, So it's referred to a location in the memory. So now, if you? so that means when we do the programming, we don't actually need to keep track of the memory address, We just can use the labels. They just come in the way, tells us where the data is. what will be the next instruction? So now I like, so I like you to look at. there are four labels, kind of, in this piece of code. The first one is the main, right? Well, what is the next one? The labels to use of labels, right? Four? We have main label. We have X, Yes, We have Y And we have that. So each of these four labels, they refer to memory location. Okay, Now, what is the kind of the memory location that main label refer to 00.. What is the memory location that label actually refer to 05.. 05.. Yes, And then we have 06,, right, And then we have 07.. Okay, So these are the kind of memory location. So that means, when you do the coding, if you want to store some data, you don't need. oh, where I'm going to store the data, You don't need to worry about it, right? Because the assembler is going to allocate a memory location to your data, So you only need to do it just using a label. It's like a variable, right. You don't need to worry about if I declare a variable like, oh, I equal to 100.. I don't need to worry about where that kind of 100 is going to store it in the memory. You don't need to, because compilers or assemblers is going to allocate a memory address for your data. So it's the same thing, right, You just use the labels. And then when you do the programming- so for example, in this case, right, you don't know oh, where actually that data like 81 is stored in the memory address, which a memory address is used. It's used the labels. I'm going to load the data. that's label X, referred to to the register one. The same thing to the kind of label Y, et cetera. Okay, So the label is just kind of referred to a memory address and programmers use that label to refer to, kind of convenient way to refer to- a memory address. Okay, And then we look at the basic instruction format. So this is the basic instruction format. So you have label. It's optional, right, It's optional, So that label could be in line with your instruction, like this one, like this one, or in a separate line. So this is the kind of label in a separate line, the main label. So this is the kind of in separate line. So this is in line, kind of, with your actual instruction, Okay. So, and then you have instruction. So every kind of assembly language, they all have its own instruction set. We already learned. So these are the instruction set, right? You have add, you have a subtraction, multiplication, division, remainder, et cetera, And then we have operands. It depends on your instruction, So it could be have one or two kind of operands, And then you can have comments. So the comments could follow your instruction or could be a separate line, right? So these are the same we'll talk about. So these are examples. This is a label. You load a word, So this kind of: load a word from memory address that acts refer to to register one, Okay. LW means load a word from memory address that acts refer to and then save that value, save that data to the register one, Okay. And then we look at how many registers we have for RAMP. We have from one to 13.. So these are the general purpose registers. So that means you will be able to, as a programmer, you'll be able to use those registers while you do the coding, And we have a special register zero that always store the value zero. It's more like a constant variable, right. You're not supposed to use it to overwrite it, So it's kind of always store the value of zero. So they just provide a convenient way, for example. so you know, that's because that requires the register And this is the base, right, If you remember. I'm going to come back to that again. And so this just kind of coming to reference the value of zero. And then we have other, a lot of special kind of registers. So, but we're going to look at stack pointer and also return address register. Those are the two most important registers as well, Okay. So here's the instruction set we already talked about. Those are the arithmetic operations. So these are the logic operations. Well, they show you some examples of bitwise, right, You're going to do assignment or practical, going to use bitwise to do apply a mask to a value, right? So we already talked about that. And then we look at the shifting. So these are something we are familiar with: load a word and the save a word. Okay, And then the next kind of set of instructions are set on test. So we're going to set the value of register 01.. Depending on the result, we're going to compare the values of 02 and 03.. And then we're going to set or not set. Set it means it's going to be one, not set, going to be zero. So those are the kind of the important instructions if you want to implement. if else, right, So if else would compare. so this is the kind of: we'll compare these two values. So we'll compare the value, So in the register 02 with value 10.. So if it's less than so, this is kind of less than right, So this is immediate value. So you're going to compare these two values. And if it's less than so, that means if it's true, you're going to set the value of sorting to register three to be one, Otherwise it will be zero. And then you can do something else, right? So this kind of? and then you're going to use equal branch equal to zero or branch not equal to zero. So these are the pairs, right? So you set. So these are the kind of you set to one if that dollar register is less than 10.. And then you use: if the register value equal to zero, you're going to that label, right, You're going to end it, Otherwise you'll just carry it on. So it's more like if less than 10, you do this Otherwise. so these are the branching right. So now, if I like you to pay attention, this is what I highlighted: right, The branch So we already talked about in the first kind of the slides. right, We do the branching. So that means somehow you interrupt the flow of the instruction, Otherwise you just kind of increment the content right: One, two, three, four, five, et cetera. But now if you look at all this jump, or we're going to look at the jump- or jump to the register. So those are the two kind of the branching, kind of the instruction. So for each one you are going to reassign the value of your program content. You give a new kind of address. Let me address your program content. So this is kind of you kind of imagine, if else, right, If, kind of if this is true, you're going to jump to O4. Otherwise you just carry on to the O2.. Okay, So this is the kind of you reassign. So if this is true, if that label and the end, if pointed to O4, for example, so that means you're going to jump to the kind of memory edge of O4, not the O2.. So you kind of disrupt the flow, kind of your instruction. So you're using the branch, So these are the branch equal to zero or branch are not equal to zero. So these are kind of if else. you use that to implement if else. And also we look at the looping example, right, The loops, So these are the label. So these are the labels. So we use that to increment as a counter. So we use the dollar register as a counter, So we kind of keep incrementing the value that's stored in the register And then we check whether that kind of has a finish. So if it's kind of less than 10, so that means it's not finished, So that means it's not zero. So we're going back to the loop again. So that is, we're going to refer back to that kind of memory address. So this is like you're going. So you carry this on right Doing this. So if it's not true, you're going back to the O1.. So you just kind of looping the O1,, O3,, O1, and O3 by changing the memory address of the program counter. So this is kind of how you. so if you want to change the order of the instruction, So you need to change the memory address stored in the program counter, Because for the CPU, right, it just follow what is next in the program counter. What is next in the program counter, Okay. So if you want to change the order of your instruction execution and just change the address in the that stored in the program counter, Okay. So this is the kind of any time you see that a PC means for the program counter, you change in the current memory address, Okay, Okay. Next we kind of talk about all these instructions. This is just a quick recap, a recap what we have learned so far. We look at how to implement if-else. We look at how to implement loop. We haven't really kind of done any exercise but just gave you the idea- And we have looked at all the basic instructions. What we haven't really actually looked at is the method. right, We're also called subroutines. If you think about any kind of programming language, you can define your method. We haven't looked at it. So this is all this kind of the lecture about. So we got half an hour to talk about the method. So that's why I'm kind of rushed a little bit. Okay, So to call method. So I can tell you. So this is a method: Add2.. So this is the kind of I call that method: Add2.. Add2.. Add2.. Add2 is just a label. You just go to that method, You just go to that kind of memory address, So the method- actually subroutine call- is implemented, just to go to that particular memory address. You just change your program content pointing to that particular memory address. right, Of course, you need to wait to come back to the calling method. So this is kind of what it does. Once you finish your method- right, You have to come back to your calling method- What will be the next instruction? Okay, So this is all kind of what I'm going to talk about. This is all about Before. I'm talking about it right Now. I'd like you to look at: So what are the memory locations that mean loop and add2 refer to? So you're going to, So what we already know, right, What will be the memory location that mean label refer to? 0. 0. Yes, How about loop? 0. Yes, 0. 03.. Because, because label doesn't have a kind of occupy, kind of the memory address, You just refer to a memory address, right, There could be an inline, right, I could just write a loop over here, right, It's the same thing, Even it's a separate line, but it's always can refer to the kind of instruction that can follow it. So that would be 0. 03.. How about the memory address that add2 refer to? 0. 0.. Okay, Now we're going to look at the most important kind of jump kind of the three important jump instruction. The first one is jump j, So that's the label that j. Well done, Okay. Okay, So it's going to jump to um, a label. So it's going to jump to the address that the label refers to. So basically what that jump does is change the program counters, the um memory address, to that um memory address that um label refer to. Okay, or two, Okay, so that's jump label. And the next one is jump to register. So that is jump register. R stands for register, just easy to remember. And then it's going to look at the memory address that's stored in the register And then assign the memory address stored in that register to the program counter. Okay, one is just using the label, another just using the value, using the memory address stored in the register. Let's do the memory address right. It's going to change the program counter's memory address that point to. And the last one, jump A stands for end link. Okay, the subroutine actually just a label. The subroutine is still a label, right? We know that you use a label to kind of point into a subroutine. So that's the two steps involved: jump and the link. So the first step, jump and link- is going to save the address of the next instruction, So that is after J, and the jump and link. the jump and link to register RA. So register RA stands for return address. So it's going to remember, right, It's going to use that return address register to remember, once we're finished the subroutine call, what will be the next instruction. right, I'm going to come back to the next instruction, the following kind of calling method, right, I'm going to show you new examples And then it's going to jump to the address of subroutine. So actually just a label. Okay, I'm going to show you the examples, You will understand what I mean. Okay, And so through that example I'm going to show you how that all those kind of three, the jump kind of instructions work. And also I'm going to show you how the arguments. So if you call a function, right, you call a subroutine, you need to pass the arguments, remember, right, You can pass in arbitrary number of arguments. For example, for that, add two. I'm going to have two arguments, right, I'm going to add two values, v1 and v2, and then the storage and return that. So this, so this is a kind of the actual implementation. I'm going to add the values So in the register four and five and cv2, register three and then return, Okay, So that's its actual message. So that means somehow I need to passing the argument of that add two. In this case I'm going to store those two arguments in register four and five. So this is the kind of register passing. I'm using the register to passing the arguments. Okay, So in order to do that, the first, I just initial some values. So this is just initial some values. So seven to register four and three to register five. I'm going to add seven and three and together. So those are the two arguments, right, I'm going to kind of add together. So I'm going to use register four and five to store those values And then I'll call that method And then call that method, Okay. Okay, Now we're just kind of: I'd like you to pay attention to program counter and I'd like you to pay attention to what is the value in the return address register. Okay, So once we finish that, we get to that point. right, We assign initial some values to our two registers and then we get to that instruction. So now you remember right, Jump and the link. So the first step is we're going to save the next instruction, the memory address of the next instruction, to the return address register. So now you tell me what is memory address of the next instruction At that point. At that point, What is the next? Zero three, right. So this is zero three, right. So that means we're going to save that. So we're going to remember, right, Once we finish, call that method, Okay, Where to go to? What is the next instruction? So that is O3. Okay, So now we. so, once we finish that we're going to jump to the address of the subroutine, So that is kind of to refer to it, right? So we're going to come to the calling that subroutine, calling that method, And now you can see that the program counter is not pointing to the O5, right, Because we're assigned. we're going to assign that program counter. So this is a jump, right, We're going to assign that program counter, the address to program counter, And we call that we add those two values together and we're going to return. So now we're going to return to the memory address that stored into the return address register, right? So what is the value O3, right. So that means we're going back. So we're going back here, right? So this is kind of how you call a method and how you return from that method, return to the calling function, mean. So now we'll kind of point you through this. This will be our next instruction. So this will be the memory address stored in the program content O3. So that's an instruction, well, you know right from the previous lecture. So they just send that value, save a word, save that, whatever the value stored in the registry to that SSD. So this is the memory address of that SSD. So we're going to save that value for display, right? And then we jump to the loop. So we kind of stay there, we stuck there, right, Your program is never going to finish, right, Just out there, okay, Because there's no kind of system called to finish, So they just count. So that means your value is going to stay there until you kill your program, okay. So any questions? So we talk about you using the register to passing the arguments, right? So we're using the register four and five to passing the arguments to be added, And then we store the memory, memory address of the next instruction, right? So this is the kind of next instruction, right, So this is the kind of next instruction to the uh, to the return address register, jump in the link And how. so now you have some ideas how actually that method is implemented, how subrouting is implemented. We're using the registers to pass in the arguments And then we use jump in link to remember where to return to right After quoting your method, quoting the subroutine. And in the subroutine, always remember you have to, once you finish your kind of subroutines, all the statements, instructions you have to return, right, So this is more like your return statement. You have to return back to the um, the calling function. Okay, So this is your. you should remember this is your return method, right, Okay, So that you jump to register, So you jump to the memory address. So yeah, Uh, no, it it won't So it it just kind of override. So probably, probably when you do that it's already have some kind of value storage. But once you do the jump and the link, it's, it's automatically it will kind of the store the next instruction or three to that return register. So it's always have some value in it and just overwrite it. overriding it. Yeah, Okay, Um, so, so now let's look at: so what's the problem of the um, this implementation? So, um, we use uh. so far, we use the registers to uh for passing the parameters, or passing the or the kind of the arguments, values, right, Um. but so this is a kind of not really um scale, really well, because if you implement a method right, How many kind of the arguments you can take? I think- yes, they will talk about overloading function- You can actually have the parameters up to 16 kind of arguments, right. So so that means how many kind of the general purpose register we have for for um, 13,. yes, So you wouldn't have enough actually register if you have a method actually that takes, uh, the arguments, number of arguments actually more than the register you have, right. So this is not really uh kind of a feasible solution. So what we're going to do? so we're going to use a stack, Okay, So, before we so the stack. so uh is going to, we're going to. so these are the two the topics we're going to talk about in 20 minutes. That's a lot of stuff actually in this lecture, So I'm kind of a little bit time wise. I always check the time but I've still got enough time, Okay, Um, so the stack, the two topics we're going to talk about. we're going to use a stack- I haven't really talked about it- to passing parameters And also we're going to use a stack to implement the subroutine course routine. So what it means is that is that you have A right, You call B and B equals C, C equal D, So these are. we call it nested kind of the subroutine course, right, So far we only see the one level subroutine course. you called add one and that's it right. But if you think about your programming language, actually you could have kind of nested kind of the subroutine course. And the next week we're kind of starting looking at recursion. So the recursion is all builds on the nested, kind of the nested core. Okay, So what is a stack? Are you still remember What is a stack? Stack of pancakes, right, We're going to talk about it in one-on-one and it's a theta structure one-on-one. And today we're going to look at the stack-based memory, Probably something I already know. the stack overflow, right, We use stack overflow a lot, but nowadays we just use Chasvix, but we actually use stack overflow a lot, If you have any kind of the questions about programming, computer science etc. So now can anyone tell me what is a stack in terms of a data structure. Do you still remember the feature of the stack? Think about the stack of the pancakes, right? So we'll talk about the queue. right, You have an exam question to talk about the queue. So what is a queue? What is a queue When you queue something? yeah, Yes, First thing, first thing, first thing. right, You queue for something, First thing, first out. Yes, And what is a stack? First thing, last out. Yes, First thing, last out. So this is more like your kind of you're like a pancake, right, The first thing when you can make a pancake. So this is your first one you make, right The next one. And when you're serving- probably you are naughty, right, You can say, oh, this is pretty nice, You want to take the bottom, right, But normally you just take the first one, right, So this is the first thing last out. Okay, So, and also we talk about the two operations that stack kind of data structure support, right? So for the list, So this is also a data structure. What are the operations that this support? Random access, You remember, right? You can actually go to any kind of the points of a list using index: The first item, the last item, item in the middle or any kind of the positions kind of in the list. But for the queue, the first thing first out, right For the stack. so there'll be push and a pop, So it'll be the first last thing kind of first out. So it's more like you push, push and then you have a pop. So this all the operation will carry out on top of the stack. It's always on top of the stack. So they just imagine: So there's no kind of this bottom, it's kind of blocked. You can't kind of the retrieve item in the middle, You can't retrieve item at the bottom, It's always happens on the top, Okay. So this is a really kind of important feature. If you look at all the nested kind of the function calls, it's kind of because it's kind of return right. If you think about this, the function is another function. when it's returning right, It's going to come pop out in that it's all the time it comes in. Okay, we'll come back to that. So that is the stack as a data structure. Now let's look at the stack as memory. So we talk about stack memory, stack memory. So it's actually called system stack. So the system stack is just a special memory region. You think about just a special memory region. So there's just a special memory in our head, right, It's not physical, The physical is just the memory kind of the memories, right. But it's all kind of conceptual kind of the thing about just a special memory region that's reserved for subroutine implementation, managed by stack operations. So that means for that particular memory region we're going to allocate, when it's reserved, you can't use it, right? So if you look at the memory region, we have a memory regions that stores your program instructions. So I would look at, we have memory regions to store the program data so that the data is x and y, right You remember. and then we also have a memory region actually that is reserved to implement your method call. So it's called system stack. We gave it a name stack because of course we're going to use stack operations to manage that memory region. Typically it is stored in this kind of high memory address: Okay, these are the high memory address, These are the low right. 00,. this is the high memory address, This is the highest memory address and it grows downwards. So that means it's kind of the move upwards. If you want to use it, it grows towards the memory zero. Okay, it will grow down into the. So when you kind of start it's pointing to nothing. So that means it's kind of your a stack memory is empty, It hasn't been used. It probably should point to somewhere right With some initial values. it hasn't been used when the program starts. So that is kind of the special: the register stack pointer, That register kind of, is full, That is going to store that, the memory address of the stack, of your system stack, the top of the system stack. So this is the kind of system pointer is going to store the memory address of the top of the stack. Okay. So this is the top of the stack And then you can use minus one to kind of move the stack, kind of the what is called downwards, right, And then you could use a plus one to move the stack, kind of the upwards, downwards, upwards, Okay, Okay. now let's look at how we push a value onto the stack. So the stack at the moment is pointing to nowhere because we only started right Or somewhere. So in order to move a value to onto the stack, first you need to somehow stack up by one word, so that you need to move up one word. So use subtraction, Okay, And then now you can load a word, save a word, So save that word, save the value, store in the register on top of the stack. So those are the two operations come together. Okay, If you want to push the value on top of the stack, first you subtract the stack by one- the pointer- and then you kind of the save word on top of the stack. So we just you can keep doing it right, And after adding some values, now the stack pointer, So it's always pointing to the top of the stack. You have to remember always pointing to the top of the stack. And then now you can pop. So now let's look at: pop a value of the top of the stack and save it to register 5. In order to pop. So that means you're going to move the stack pointer, what is called the down by one word. You're going to move downward, right, So you're going to move that downward. And then, are you sorry, the first you need to load the data, right, Because it's always so. you need to save that data. You need to load that data to register 5.. And then you move it to one word downward, the down by one word. Now this is actually the top of the stack. So if you don't care about the value. so, for example, you don't care about it because you don't want it anymore, So you don't need to actually load it into a register. So this, just in case, I still need it. right, You load it into a register. What is the zero brackets to this? So these are the offset, if you remember. So this is the offset, So this is the so, um, so, add offset to a set pointer. So I talked about this, uh, the last time. I just don't have time to review it anymore. Okay, So, uh, you're kind of, it's just a convenient way if you remember x and offset something, right, So the x provides offset. So you just kind of: so that's all, just, yes, because it gives you the relative paths, Because you set up a kind of relative, you set up base, right, And then you can just add in, So this provides a relative path. Okay, So you will, you will see, I will see. Okay, Now, uh, so let's just uh. so now let's look at the? uh. I won't have time to finish it, but I'm sorry to stay around. So now let's look at how we actually use stack-based parameter parsing. And now we're going to, um, add those two arguments, the V1 and V2, uh to the stack. So because it's first in and first out, so these are added in reverse order. So that means we're going to add the V2 in first and V1 later, because it's kind of reverse order, because it's kind of the uh last in, first out, right? So we have to do that. So the next time when we do the popping, the V1 will pop first and then V2, when we do the saving, we save the V2 first. Okay, Now I have to move a little bit fast Now we. so let's see the implementation. We just go, uh, quickly, Okay, So those are the two values we add into four and five. And then now, uh, we make the first. so these are, we save the first value. So we save five, two on top of the stack, And then we save the second argument, which is actually not second. We run on top of the stack. These are the kind of already on the stack, right. And then we're ready for our register. We are ready for call to the add two. Okay, So now in add two, we, because everything have to be operated on the register. So in that method, call, because we're going to move these two values to register. So now I'm going to decide I'm going to use register five and the six to do the addition, Um, but my register five or six might be used by other kind of the subroutines or might already have some values in it, right? So the first thing you need to do you are going to back up the values of those registers. Okay, Anytime you use the register you're going to back up. So these are the kind of ways I'm back it up. So now I kind of increment my stack by two, uh, subtract by two. So now it's pointing to here, right, So this, I'm doing the backup, I'm get back up the value of five, which is this one, And I back up value of register six. I don't care, actually, whatever the values in the register five or six, I just back them up and then I'll be able to use it. Now I just I'm kind of start loading the arguments, right, So those are the arguments I stored on top of the stack to the register five or six And then I do the addition. There's some kind of weird characters. So these are the. I do the addition. So now you can see the two and the three. why kind of using those kind of together, right, And these are provide the base And I do addition. And then now I kind of the restore, restore the original values of five and six And then I pop. So these are the kind of pop, these two values. Now my message kind of finishes, right. So that means I, whenever I call function, I use all those registers to do addition. I just store the old values, original values kind of, of those registers on top of stack. Once I finish using them, I kind of restore the original values back to those registers in case those registers, because I only have a limited number of registers, right. So I need to kind of I just use the stack to back up any kind of registers I used And then, once I finish the call, I coming back to here, right, I do the kind of addition again. So I pop these two values once I finish this. So that means my stack, the add2 finishes that. the system stack restore to its original state before it's calling the add2, right? So in this case, yes, But there could be other methods to call, right. So you imagine in a big program, right, Other things, Yes, other things, but it doesn't matter, right, But at the start of a program it explains the last value in that? Yeah, yeah, probably, Yeah, it depends. Okay, so now you can see that the stack is used to store the parameter values, right. And also the stack is used to back up the values of registers using the subroutine And we kind of restore its space once we finish the call of the subroutine. Next we're going to look at how the stack is used to help us to support subroutines that themselves call subroutines- Those are the nested ones, okay, Okay. so this is a very simple example. You actually don't need to worry about the method. The method is just incremented by one. But we're just looking at the kind of return address because we're going to be able to go in back to the kind of calling method. So this kind of will be okay at one level deep. So for the main method, we call the increment by one, call that method again and then we finish it right. So this will be okay. I'm going- I don't have time to talk about it, But we're going to look at if the kind of method calls two level deep. So that means we call method increment by two Inside that method. actually, we call the other method. Now I'd like you to look at, to pay attention to the value that is stored in the return address register. Okay, let's start. So, when we call the increment by two, what will be the value of the return address? O2, yes, And we go here. right. So what will be the value of the return address once we call by one O4. And then we call again, what will be the value? O5, yes, And we return right, And then we go back to O5.. O5. And it's just stuck there. So what happens? We can't go back to the call function, right, The recording function of by two. I'm moving a little faster because I'm running through time- Okay, What happens here? We kind of lost. we kind of lost the O2 on the way, right. So if you go back again, right, So now we can. when we're calling in the by O2, where the register O2 is over here, right, And then we will call that. So it's kind of override because we're not called by two. right, We're going to store the next O4 and we have to store. the next will be O5, right. So once it finishes, we're going to return O5. Okay, Give. so I'll leave it to you to actually to digest a bit. I'm running off the time, So that means we start here. What we can do is we're going to also store the return address on the stack. So that means every time you call function, you're always kind of the push the return address on top of the stack And then after you call these functions you restore it. So that means every time you A call B- right, You can remember it's calling functions memory, kind of next instruction, And inside B you remember what will be the next instruction And for the C, when it's returned, it's kind of able to coming back The next they call. right, Because it's remember where to return to, because all these kind of return address you only have one return address, kind of the available, in case it's overwritten, for the kind of nested calls I have. you just push those kind of return address on top of the stack and restore it And you will be able to go back to the calling function. Okay, So now we look at the stack used to store the value of arguments, to store the all the values of all the registers in the subroutines and also to store the return address. All right, the three things, while coming back to the stack memory. next week again, Okay, I'll see you next week.
</p>
</body>
</html>
    