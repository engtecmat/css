<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Searching Algorithms</title>
    <link href="https://fonts.googleapis.com/css?family=Kadwa" rel="stylesheet">
    <style>
        /* global variables */
        :root {
            --light-mode-background-color: #F0F4F8;
            --light-mode-h1-color: #191970;
            --light-mode-text-color: #191970;
        }

        body {
            font-family: "Kadwa", Georgia, "Times New Roman", Times, serif;
            line-height: 1.6;
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background-color: var(--light-mode-background-color);
        }

        p {
            white-space: pre-wrap;
            text-align: justify;
            font-size: 30px;
        }

        h1 {
            color: var(--light-mode-h1-color);
            font-size: 40px;
            text-align: center;
        }
    </style>
</head>
<body>
<h1>Searching Algorithms</h1>
<p>
    Oh, this is more like a fish. Oh, that's great, So you can choose a fish. Okay, let's get started. So the first thing: actually, I'd really like you to come to the lectures, especially for the next two weeks, because university is going to start a space survey. So that means I don't know what would happen, right, if they come to the lectures and they find it's very empty. They're going to give us smaller rooms or they are going to do something I don't know. So that's kind of one reason you come, just support the lectures right, show that you still care about the lectures. So the second, the points I'd like you to come to the lectures is: we just finished the exam, the setting, the exam questions. So there will be- I think I'm going to talk about exam questions in the last week. If you've done one-on-one, you may know that for the one-on-one exam questions, I pretty much gave you the question format and some hints about what the question will look like. But that won't be the case for one or two. But I will somehow go through what will be the questions. So there are going to be 10 questions And there are two, I think the last two questions- One is about recursion, Another one is about searching or sorting algorithms, So big O's. So that will be actually the two questions, two kind of the big questions right, about those two topics. And these two kind of topics is going to be covered actually in the week 9 and 10 and 11.. So if you come to the lectures, basically I don't think that will be that difficult. If you skip the lectures, probably that will give you the trouble when you do the final exam, Especially your final exam, you have to pass 40%. So no matter how well you did, actually you have done, for your kind of internal, all the practicals, all the quizzes, assignment one and plus assignment two- even you achieve like 100% right And then your final exam, for example, is only like 38. Yes, you're going to fill this paper. So what I mean is come to the lectures right, especially the recursion, which I think is quite difficult, And also the sorting part. If you just follow my lectures, I don't think that will be that difficult. Just need to come here to follow my kind of lecture notes And if you have any questions and ask- and there won't be any kind of issue to passing- to at least do those kind of two questions. Okay, So today we're going to look at searching algorithms. So for the searching algorithms, don't be scared. Actually it's quite easy to understand. So if you haven't really kind of know them, it's very kind of important, the computer science topic You're going to. so in this lecture we're going to learn two simple searching algorithms. One is just sequential search, Another is binary search And you're going to do more kind of learning, more kind of advanced searching algorithms. If you take, if you're going to take one, two, two, one six, which is kind of AI, kind of the paper. So, like I said, we'll just give you a kind of a taste of actually what searching is about. So, actually, the searching algorithm, you have to use searching algorithm a lot. probably you haven't really realized. So this is very simple. This is probably the simplest searching problem. So you're going to find a particular item in a list of objects, For example. you have a list of numbers and then just need to check whether a particular number is in the list or not. Okay, So another example: probably you use every day, right, You have your phone and they all have the contacts, right? So the contacts you have the name of your friends and also their phone number, et cetera, email address. So this will be the contacts. So that's just a simple app where it's stored on your phone. And another one is if you still use Google search engine or other kind of the search engines, you have to be searching all the time. So I'm going to come back to a Google search engine, give you just some kind of the fundamental ideas how that search engine works shortly. And if you're using an e-commerce website, if you want to buy a product, for example, you just type in: yes, I just bought a bunch of chocolates. So I just type in the chocolates, right In the new world website, it just kind of shows up all the kind of products that are related to chocolates. And also, of course, if you want to, all the social media, you can search. right, You do the search Even. you can do the search, for example, So this is the search on the Mac, So you can actually do a search of documents, So you can do a full text search, You can search whether a word will occur in a document. Okay, so that's pretty much. it's very useful. So next, because actually we got time actually today, so I just want to add a bit extra kind of topic to show you actually how that search works. Just to give you a very kind of brief idea. you may already know. If you've already know, just bear with me. Okay, so that's probably something you already know. So the search engines, all these kind of search engines, they all started from kind of using a crawler, So that is going to call all the kind of it: just kind of gather all the documents from the internet, web pages, all the available right, If it's hidden, if it's in the database, you wouldn't be able to actually get the information. It's kind of all the available web pages from the website. And then, once they have all these kind of the text or could be images, videos- you're going to store that into a database, document collection, which is called the document collection, And then the indexer is going to kind of look into all these document collections. And then the user. so if a user sent a query to the query processor, the query processor is going to look at index and then return the kind of list of documents. It's more like you're typing a query term at Google search box. it's going to look at its index and return a bunch of the web pages. Of course there's more than that, but I just only want to talk about the basics, So about the index, so what that index will look like, which is actually quite simple. It's more like index nowadays if you buy a book, right? So in the old days if you buy a book, so actually there's an index at the end of the book, So that index just tells you all the words, right, The index is kind of on the word and then you will see the page numbers that would occur. So basically it's the same idea. So I just want to show you- I just use those four documents. So these are just four. Just imagine these are. these are the first document, So these are for a document ID. one, two, three, four got four documents. So these are the texts of those documents. So the document one just has simple texts like this: This is the kind of text for document two, three and four. So the first kind of the task for building an index is actually it's called extracting all the terms and associate the document ID with that term. So what it does. it goes through each item, so each word or called term. It depends on how you define a term, right, I'm going to extend it. So just imagine you go for each word here, So that will become new home, south top forecasts. So this will be kind of document ID associated with that word. Okay, So this is done for every kind of a document in the document collection. So in this case, the first one, two, three, four, five, So these are the five words coming from the first document, and then these are the four come from the second one. So those will be the list, right, the document IDs, document IDs, et cetera. So the last, so the July new home, south rise, coming from the fourth document, Okay, So this is the first step And then the next step is called sorting. That's where we're going to learn the sorting algorithms, right? So this is also irrelevant. So we're going to sort the terms, the sorting terms, according to its alphabetic order. So this will become so this is a kind of sorted version of that, the list we just built. So we're going to have forecast, the alphabetic order, right, We're going to have forecast and home home, because we have actually four homes. So this is the first home, the second, third and fourth. So we're going to have four homes. So these are their document IDs. So we've done that for all the terms, just sort them. So this is the kind of second, We're going to learn different kind of the sorting algorithms And then after that we're going to do the posting. So the posting means is that we're going to combine all these kind of the duplicated terms. So for that one the forecast is only occur once, So we'll also calculate its frequency. So it's just a number of occurrence that term occur, So the frequency occur once The posting. posting is the list, just a list of documents. So it will be the forecast home occur four times. So those are the four times right And the occurring document: one, two, three, four, and one two, three, four, et cetera. So we've done for each term. So once we have that right. so this actually is index. So this will be the index, the simplest form of index. Now, if you think about that index, so now if I search the term home, so it's going to look at the index home. Yes, it's going to return all the posting lists. So it occurs in the document one, two, three, four. So if you are building a simple search engine, right, you just need to use that document ID to go to the database and retrieve all the kind of four documents returned to me, If you think about the simplest search engine right. So if I search home, you go to the index. So this will be our index. Finally, if you go to search home and then you retrieve all the kind of document IDs and return to me, So of course you need to think about what will be the data structure to store that index, right. So there are many ways to do it. So if you do, the program probably could just use the hash table, hash map, the dictionary to do that. Of course, for the search engines, for the Google, they have more complicated kind of algorithms, But these are the fundamentals. Pretty much what every kind of search engine does is they build index. But for the Google they might have a page rank algorithm. If you are interested, they are actually looking at not just the individual words, they actually look at the links. So if you think about all the web pages, right, They all have these HTML links. Yeah, HTML is all a tag right In the link and the link kind of all the links pointing to that particular document and all the kind of alter links that kind of document is pointing out. So those are the kind of just the kind of combinations about everything. So that's the kind of. so that is kind of page rank algorithm, But this is kind of just a basic. I just want to give you some ideas about how that search engine works. Okay, so that's kind of a little bit kind of complicated the search algorithm I need to do, But today we're going to look at two simple ones. We always start with the simple ones. The first: we're going to look at the sequential search. So the sequential search: if I ask you if I want to search a number 22,, if I want to check whether number 22 is in the array, what are you going to do? So, if I give you this question, if I want to check whether number 22 is, whether it's in the list or not, what are you going to do? What are you going to do? Very simple, right? You just compare. you just go to the list, right, Compare to one to see if it's equal or not, right? So this is exactly the sequential search task. So it just starts with zero And then, so this will just check whether we get to the end of the list, that array, And this will just. if it's not equal to the item, so we carry it on. right? If it's equal to the item, so that means we already found the item in the list And then we're going to return the index of that item in the list, which is quite simple. I'll just give you away one minute to go through the code, Okay. so of course, the next question is: how efficient is this algorithm? So we're going to have a lot of sorts of algorithm. we're going to need to compare them. which one is more efficient than the other one? Okay, so how we actually measure the efficiency or kind of performance of algorithm. So typically, when we're kind of looking at them, we actually start with thinking about how many operations in this method. So we're going to look at operations means how many kind of statements, how many kind of computations we need to do, operations in this method. Okay, so now let's just do some exercise of counting operations. So for the first one, which is assignment, how many operations? One, okay, one operations, because this is just an assignment. So this is the kind of assignment operation. How about the next one? One again, yes. The next one, the next one, the third, Two. yes, There will be addition and assignment. So that one, Two, I++ is just a shortcut for this. one, right, Two. How about that? one? One, One again, right. So last one, Three, yes, It's very easy. Okay, the if else, how many? So there's one over here, right, And the return is also an operation. So how many? Two or three? Two or three, Two, yes, It's a branch. Either that one return, two or fourth, right, That's not three, okay, just two. Okay, how about that one? Do that one? You can quickly just tell me how many? Four, Only four. That's a y-loop, right, That's a y-loop. How many times that need to do? How many times that need to do? Okay, so if we look at the basics, right, So this is one, this is one, this is two. But how many times that one needs to do? How many times that two needs to do? Ten, right, So this will be the ten times. This will be the ten times. Yes, there will be Thirty-one, yes, Okay, Now let's look at that one. So just pretend that new is one kind of operation and then assignment is another one. So let's just calculate the basic, right. So we're going to have two here, One for this assignment. So this is only once, right, We already learned the four loops. This is only once, So this will be twice, right? So we need to do the length and we need to do the lesson. So this is two times, this is two times, this is two times. So of course, this is a four loop, right? So that means we need to add more. So how many times actually this is going to happen? N plus two? Yes, How many times of this? N, yeah, Multiply two, not N plus two. N multiply two, N multiply two. This is N multiply two, right, Okay? So that will be six, N plus four. Okay, Six N N plus four. Okay, You are following me, right? You are following me, Because this is going every kind of iterations they're going to need to do right, Two times. So they're going to have N kind of iterations. So that means you have to N multiply two, N multiply two and N multiply two, Okay, Okay, How about that one? So now we have two, kind of we have two nested loops, right? So this is the inner loop. We have outer loop as well, Okay? So for the question like this, we just have a divide and a conquer, right? So this is something I'm going to talk about next week: divide and conquer, Okay. So two, one, one, two, two, One, two, two, two, right? So the world didn't know about this, right? And then now we, the first we're going to look at inner ones, right, We're going to look at that inner one. So we're going to look at that one inner four loop. So that part. So for the inner loop, so we just add them up, right? This will be six N plus one, right? So there will be N, two, N two, N two, N one. So it will be the six N plus one. No, no questions, right? And now the question is: how many times? how many times, not how many times, how many times of inner loop will be carried out? So how many times that kind of the chunk of the code is going to carry out? How many times? N? yes, because this is kind of inside that for loop, right? So every time you increment I to zero, one, two, three- you have to go do that for loop again, right? So if I equals to zero, yes, you do that for loop once, And then, once finished, you increment I to one and then you go into that for loop again, right? So that means it will be N times. You multiply them together, So that will be the N times. So this will be the inner loop, So it will be the N times: N to the of two, N plus N, Okay. So now it's, once you've done that, it's not that difficult, right? So that's for that part, Okay. now let's look at the outer one. so that one. So how many times do I need to do? 2N, right, So this is another 2N. So we'll have 4N plus 1, okay, So that is for that part: 4N plus 1.. So now, if we add inner and outer loop, so that will be that one. So this is the inner loop, right, We just count it from here, And so this is the kind of total number of operations we need to do. Have we finished? No, we still got 3, right, We still got 3 over here. right, We still got over here. So that means we add another 3.. So this is actually our final number, Okay, So this seems very complicated, right? So if you think about this, this is pretty much the simplest, probably the for loop, the nasty for loop you're going to do. If you can just imagine, if you add more here, probably add something outside, right And here, and it will become kind of the complicated, okay, Okay. So now, if we look at that sequential search, so that method, we're going to do the counting the operation again. So we just carry on, we're going to look at each line for code and you're going to tell me how many operations are there, Okay, So first line, we're 1,, okay, And so that 1 will be 2,, right, We just put a 2,, oh, no. 3, 3,, 3, 3.. So we have 1 here, 1 here, and end, there'll be 3.. Sorry, there'll be 3.. Okay, And then we have 2, but of course this is a wide loop, right, We have to multiply the array length, okay, So there'll be the number of kind of items in the array. So of course this is a worst case, right. So that means, well, if we are not going out kind of the exit to the loop, the wide loop kind of earlier, So that means we have to carry on, see if we couldn't find it. So, and then there'll be 1, so it'll be 1 of them, So, and in total, so it'll be the 5n plus 3.. Now the question is: right, if I come here, right, if I show this to you and then I tell you, so this is kind of 5n plus 3, and you may think, actually, probably, if you look at that kind of implementation, it's not very sufficient. You may be able to do some kind of modification, So that means you may get different kind of result. You could have 4 multiply n plus- I don't know- 1 or 2 or 3, et cetera. So this is kind of become more kind of. so this is actually the simplest. And then if we have more complex kind of the problem, so that means if we're going to do all this counting number of elementary operations, so that can get quite complicated. I already showed you how complicated it is. right, But for our kind of evaluating actually the complexity of a searching algorithm, so actually what we actually need to do is actually counting the number of comparisons with the items in the array. So we don't need to actually counting every kind of operations in our method. We only need to counting the number of comparisons with the items in the array. The reason is so I'd like you to look at these two kind of the function. So now my question is: what is the difference between these two and these two? when n is extremely large, So when n is like billions, do you think they are quite different? When n is really large, If you multiply 5 to 1 billion- whether it's different- you will multiply 1,000 to a billion, a billion if it's kind of infinite. So we'll come actually. so these kind of the two functions have the same complicity, which is just n. So we're going back to that later. We're coming back to that idea again and again. Okay now. so I'd like you to look at the code again. So could you tell me which lines? or do the comparisons with items in the array? So actually compare the items in the array, Just do the comparison. Which line of code Where we actually do the comparison with items in the array? So this is the actual comparison, right? So how many times do we compare that Once? right, And then, the worst case, we need to do the n times. So this is the actual complexity of that algorithm. So this is actually n. Okay, it's just bigger n. So if we just space on that, So the complexity of that is n. Complexity of that is actually a question mark. right After the final lecture you'll understand. actually it's also n, Okay. so that means those two functions actually have the same complexity. They actually, if you measure them, if you think, oh, whether they? so you come up algorithm with that complexity and you come up with another algorithm with that complexity and you want to see whether they actually, which one is better. But I can tell you they're all the same. actually, because they all have the complicity of n. They're all the same, They're all on the same scale. Okay, so that is a sequential search. Next we're going to look at binary search. So I'd like you to look at that array. So could you kind of just look at the array and think about what is special about that array. Just look at the numbers in that array. What is special about that array? Yes, they're all sorted. So they're all sorted in particular order. It doesn't matter whether it's kind of descending or ascending, They're all sorted. Now if I ask you, if I want to find a number 22, whether that number 22, is in that array, what are we going to do? Are you going to compare that number with every item in that array? Are you, If it's sorted, Are you going to compare the 22 with every number in that array? No, you don't need to because it's sorted. You have extra information, It's sorted. So where are you going to compare? Yes, the center one. So in this case it could be 20 or 21.. Depends on how you kind of do the calculation right. So, for example, if I compare with 20, and do you need to actually compare the 3,, 7, 11?? No, Again, no, All you need to do is just compare with this one, right, And you're going to do the same. So this is exactly called binary search, And so that means actually you are doing the fewer comparisons, right? So that means you don't actually need to examine every single element. So this is actually the binary search code. This will be our start and end. Just maintain the two kind of the pointers, So one pointing to the start and the other one pointing to the end of our search space. Okay, I'm going to show you, And then you check whether start is less than end And then you calculate the middle point. So this is the kind of you do the comparison in the middle point And then you do the update and et cetera. Okay, So we just go through that. Just give you a little kind of visual about the binary search. So this will be our start and end. So this will be the items we're going to looking for. So this time will be 45. Okay, When we start, the S star will be the zero. So this will be the last item, Okay. So this is kind of when we start And then we calculate the middle point. So in this case, we will give us 20.. So that middle point will be: so zero plus seven is seven and divided by two, which is a three right, Which is three. So that means we're going to have three index. So this will be the item. We use that three to retrieve the items. We're going to do the comparison Now, because 45 is greater than 20, so that means we don't need to worry about that kind of the part half right. So now we update. So in this case we update the start point of our searching kind of space. Now the S becomes middle point plus one equal to four. So now we're kind of carrying out that kind of range, right? We don't need to worry about that, because we all know that all the numbers on the left will be kind of smaller than 42, 45. And then we do the same right, We calculate the middle and then we do the comparison. It's still kind of larger than the middle one, 23.. So that means we update our start point again and then we carry on And until we find something that is kind of go to: this point: 45 is not greater than 45. So in this case we're going to update our end point, So the end point will become middle point And then we get to that point. So in this case, so this condition, this is a wire loop, right, We can exit, right, Exit, So exit our for wire loop, And then at that point we'll just check whether these two items equal. Now we just check that 45 equals to 45, find it, and then we return the index. Otherwise we return minus one. So that means the item is not found. Okay, So this is actually quite straightforward. but we need to look at complexity, right, We need to generalize the complexity. We already know the sequential search. the complexity of the sequential search is n, right, n is actually the number of items in the array. So this is the complexity. So that means the more items in the array, the more kind of the time that sequential search is going to take. So now let's look at the binary search. So this will be the two. so if I ask you to check, right, so this will be the two places actually to do the comparison. okay, So one is when we kind of check whether these are greater than right. This is the place. So this is the one kind of comparison we need to do, And after I exit the wire loop, so this is another one comparison. we need to do, okay, The two places. Okay, now let's look at how we actually be able to generalize, to give us some ideas of complexity of binary search. So these are actual points. actually we do the comparison, right, We did the comparison. Okay, now, so at so example I used actually has eight items in the array. That's the reason I chose eight, because it's a power of two, It's a kind of the multiple of two Of Okay. so now we have eight items in the array. So eight is two to the power of three. right, We can rewrite eight to two to the power of three. So now we, so we go back to that. We do the three comparisons. right, Three comparisons. These are the three comparisons we did in the wire loop and also we did one kind of comparisons outside one loop. So that means for the eight items in the array. so the comparison we need to do is a three plus one. Now if we have 16 items, elements or in the array, you can do that, You can evaluate, right, We need to do the four plus one comparison. We can write the 16 to two to the power of four and the 32, two to the power of five. we do the five plus one comparison. Now you can see the patterns. right Now you can see the patterns. If we have two to the power of k elements or items in the array, we need to do k plus one comparison. Now if we have n items or elements in the array, so now we make n equal to two to the power of k. so k is two log n, base two. okay, So in this case, for the n elements in the array, we need to do the n log n, base two plus one comparison. So that is the complicity of binary search. And you may think how good it is. So this is our ego complicity chart. So the sequential search is in that fair range. So this is fair, right, This is fair. And log n- so anything kind of log n, doesn't measure the base right Or base two or base three, So it's in the good range. So that means our binary search is actually really good. But for the excellent range it's constant. So what constant means is that no matter kind of how many items you add into you need to deal with the searching or whatever, the complicity of your algorithm is constant. So, for example, if you're going to deal with 100, or if you're going to deal with 1 million, but it's always roughly give you the constant kind of the performance. So that is kind of bigger. one means The hash table is able to give you that. So that's why I keep talking about why hash table is very efficient, right, The data structure, Because the performance of course have to be maintained really well. So that's something actually you're going to study in the second year data structure paper when you're talking about looking at a hash table. But now we already learned two, right? So this is sequential search performance, This is kind of the binary search performance. So once we get to that point, probably if you have an algorithm that is factorial of n, probably it's never going to finish in your lifetime, basically, Okay, So now we look at a sequential search or binary search. We always look at an algorithm in the kind of the three cases: One is the best case, Another is average case, Another is the worst case- But we're always using the worst case actually to measure the performance of our algorithm. So what is actually the best case? Can you imagine What will be the best case of sequential search? Yes, the first element is what you're looking for, right? It's more like this, right, If you have that one, the first item- actually first element- is what you're looking for. So that means only you need to do once and then you find it and you kind of you don't do kind of anything else. And also for the binary is also the first item. you just pick the middle one. right, It just happened to be the. you are extremely lucky, happened to be the one you are kind of looking for, And that's so. this is kind of the, the, the, the best case. So what will be the worst case? Yes, So worst case is it means you have to go through each element in the array and then at the end you couldn't find it right. What is the average? Yeah, Not halfway, somewhere, right, Somewhere in the middle. So that means sometimes what we have to go towards the end, Sometimes you have to kind of you're lucky, probably at the front, Sometimes what we have to come in the middle, but it's just average, right, So where? but for when we're describing the algorithm, we're always kind of looking at it's worst case. So that means you couldn't find it. We always, always use the worst case to describe the performance of the algorithm. So for list, list already have a method called binary search. So this is example: I have a list of a string, I add a few dinosaurs into the list And then I just do the binary search of that list just to see whether the binary search already implemented for you. So if you want to use a binary search, right, you actually can just add items in the list. So the binary search is going to return the index of the items in the array. But now you, if you look at it right, if I do the binary search of the items, I just add it in It. actually, some gave me minus five, some gave me one and two, some gave me minus three. So minus five means couldn't find it. Minus three means also couldn't find it. One or two is be able to find it, actually return the index. So my question is what happens here? Whether that binary search function is broken, Because for the first one, so if it works, what will be the index for the binary search? for the first one, going to return Zero, yes, What is actually returned? Minus five, Okay. For the second one it should be: yes, it should return one, right. Well, for that one it will return two, right. So that means correct. But for the last one, it will return a minus three. So that means you couldn't find it again. Is that method broken Or we did something dirty? Yeah, You need to sort the list out there. Yes, you need to. For binary search to work, you need to sort the list first. Always remember that, right. So what do you do? They already have- I think they already have- a sorted method. Yeah, Okay, Now let's see whether it will work or not. Now it's kind of working right, Somehow it's sorted. Of course it's a sorted kind of list. Okay, Always remember using the binary before you use the binary search, right, Always sorted, Okay. So next I just want to show you the performance of sequential search and binary search. Just give you a taste of the difference between the N and the log N base 2.. So how fast actually can you achieve just kind of reduce, kind of the form N to log N base 2. So, of course. so when we're dealing with all this, we're always looking at big numbers, right? So for example, if you want to do the, just do so. this is actually the number of items. So the max is number of items in the list. So at the moment I give it 100 million of items or elements. So if you had to do the 1,000, probably it doesn't really kind of make huge difference if I do the 1,000.. So I, because I need to do the ordered array, I implement a method So that method just generates ordered array. I use some kind of the random numbers to generate, but has to be ordered right. I use the random, but not just one: children, 99, right, Just every kind. I use a number, random number generate and then it's ordered And then I use a stopwatch just to. so I first I do the binary search and then I create a new stopwatch and then I do the sequential search. Okay, So it gave me the time. it would take in milliseconds. So let's see where the. so now we're actually searching 1,000.. So now you can see it's not much difference, right, for the binary, Yes, it's slightly kind of faster For the sequential search. it's kind of the. so one is 0.15,, another is 0.2.. It's not kind of huge difference. And also we are going, we are looking at the worst case, right, The worst case. we couldn't find it right. So that means if it's returned, the index minus 1, minus 1, say we couldn't find it. actually we're measuring the worst case, which is really good, Okay, Now let's try 100 million. So how many? so it will be another five zeros, right? So is that enough? Okay, Yeah, five, Is that 100 million? I can see it takes time now, But it shouldn't take that long. Is that I got too many kind of the zeros? No, it's fine. Yes, Okay, Now you can see the binary search. this is also the worst case, right? So that means you couldn't find it, So they have to search every kind of elements in the array. So the binary search, which is still 0.2 milliseconds, And then now we have sequential search, which is, I think the reason is just because it takes a long time to do this sequential search, right, It's almost how many times faster- Probably 3,000 times faster than the binary search. Okay, Now you can see the difference now. right, The whole that you can reduce your time from N to log N, base 2.. If you study- it's kind of the mathematics in the higher school, you can see the whole, that kind of. you can form that line to that logarithm. I always give you that kind of one, Okay, so hopefully I just want to show you the comments. you're right, using the binary search as possible as you can. So what is the catch of the binary search, You have to do the sorting. So that means sorting also will take time. The best kind of sorting algorithms actually you can achieve is N multiply log, N, base 2. So, which is actually slower than sequential search. So if you do so, that means if you want to sort once and search, sort and search and sort and search, probably you'll be better off just using sequential search, Right, But I'd like you to think about in what scenario that binary search will have kind of trade-off. You want to use a binary search? Yeah, We sort once in the search. There are lots of options. Yes, So that means you only need to sort once. Or you can sort something offline, for example. It's more like all this kind of database they do. if they want to use a binary search, right, They can sort it offline And then overnight, when it's kind of not off, kind of peak hour, And the next day it's sorted and you'll be able to use it. So you just need to sort once. Otherwise, if you sort, search, sort, search, And then you're better off just using the sequential search, which is just N, Okay, Okay. So next week we're going to look at all the sorting algorithms, Okay, Okay, We'll see you all next week. right, We'll talk about the space survey. Okay, We'll see you all next week.
</p>
</body>
</html>
    