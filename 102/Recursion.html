<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Recursion</title>
    <link href="https://fonts.googleapis.com/css?family=Kadwa" rel="stylesheet">
    <style>
        /* global variables */
        :root {
            --light-mode-background-color: #F0F4F8;
            --light-mode-h1-color: #191970;
            --light-mode-text-color: #191970;
        }

        body {
            font-family: "Kadwa", Georgia, "Times New Roman", Times, serif;
            line-height: 1.6;
            max-width: 800px;
            margin: auto;
            padding: 20px;
            background-color: var(--light-mode-background-color);
        }

        p {
            white-space: pre-wrap;
            text-align: justify;
            font-size: 30px;
        }

        h1 {
            color: var(--light-mode-h1-color);
            font-size: 40px;
            text-align: center;
        }
    </style>
</head>
<body>
<h1>Recursion</h1>
<p>
    Thank you, Thank you, Thank you, Thank you. And also on Thursday as well, and on Friday we're going to look at sorting algorithms. One of the sorting algorithms actually is written using recursion, So we're also kind of on the topic as well. So it all kind of depends. So if you want me to do another kind of lecture on recursion, I can probably just show you more examples. So we kind of together to write some recursive functions. So I did a tutorial actually last year which I think was really good. Just give me some insight of what you actually understand by recursive function, So we'll see what happens. So, because we somehow we can finish all the topic earlier. So that means I can come back to some kind of the topics I think could be challenging. I think recursion is one of them. Okay, So now. so before we talk about recursion, so now let's just look at divide and conquer. Basically, recursion is kind of can be described as method of divide and conquer. So divide and conquer approach- actually that's nothing kind of new to you. It's more like decomposition, right, When you have a bigger problem and you want to divide that big problem into smaller problems and then you focus on those smaller problems and then once you solve all these smaller problems, and then you combine all these solutions to these small problems and give you the answers to the original big problem. So, but for recursion it's somehow kind of the side different. It's kind of you breaking down problem into two or more sub problems of the same type- Decomposition way, decomposition a big problem, So your sub problems could be different, right? So for example, if you want to cooking a dinner, you might need to come prepare all the vegetables and et cetera. So those are the kind of the sub problems could be the different task. But for the recursion, or divide and conquer, so you can break it down probably into two or more kind of sub problems of the same type or related type- You'll understand what I mean shortly- And then, until these sub problems or sub sub problems become simple enough to be solved directly, And then we combine the two solutions to all these sub problems and then they'll give us the solutions to the original problem. So I'd like you to think about- I put that picture over here, So I want- so this is just a loaf, right. I want you to think about how are you going to slice this loaf evenly? So what will be your approach right? Are you going to start from beginning, just kind of slice them, or what will be the best approach? So you're going to do it right. You're not going to ask someone else at New World to use a machine to do it right. So the best approach is: you might look at it right And you find a middle, you slice it and then it become half. So you have one half, another half and then we call it left half and right, half, right, And then you work on your left half and then you find the middle point or the middle kind of the- again, and then you slice them to half And then you work on the right- half right- And find the middle point and slice again, And then now you end up with four parts right, Four proportions, And then you may work on the left and for each kind of the half you slice them into half again. It carries on until you're happy with your kind of the final slice, Okay. So basically, this is the kind of same idea of the divide or conquer, Okay. So we're going to show you more examples. So recursion: Okay, Recursion is similar as the divide or conquer, So it's just a curse when the definition of- so this is actually the definition from Wikipedia. It's just definition of concept or process depending on the smaller or previous version of itself. It's smaller or previous version of itself. So this is a kind of a racial form of recursion, known as Jorsi effects. So if you pay attention to the picture, So this is a cocoa tin, right? And if you look at that, the cocoa tin that lady is holding, actually it's the same kind of image, right, It's the same image. And if you look at it, if you zoom in, so actually you can see that it's holding another kind of image again. So it's kind of recursive, right. So this is one of the racial form of recursion. Okay, This is actually started a very long time ago, It's like 1940.. And then we have another kind of example. So this is called Schiepinski triangle. So this is Schiepinski triangle, So, which is formed by- so if you look at- so this is a start from this triangle, And then you subdivide this triangle recursively. So this is kind of the first- so if you think about this, it's just the first kind of generation. So you start from that triangle And then you subdivide it into- so now become four, right, The four kind of equilateral triangles, And then you're working on the three- these three black ones- And then you repeat the process again, So this is kind of the top one, And then you subdivide them kind of into the smaller equilateral triangle again. So you repeat the process on that one, that one, that one, And give you that And you repeat again the same process, recursively, right, And eventually you end up with a triangle like this. This can keep doing it right Until you're happy with the final form. Okay, so this is the kind of the visual form. So it has been used a lot actually in either kind of in decoration or- so this is just a kind of special triangle that is formed, probably in art- There are a lot of examples in art actually to get all these different shapes or forms using recursion. Now let's look at all kind of complex science, right, The problems. Okay, just gave you an example of actually how we actually using recursion, how we actually using divide and conquer to solve a problem that actually you're already familiar with. Okay, so this is a kind of maybe simple example. So you have array- I like to sum up- a non-empty array. So this assumption, this array is not empty. So you already know how to do it right, If I ask you to write a loop, So to do it, Okay. so if I ask you to write a loop to do it, something already knows I don't know how to do it- You have a sum and then you use that as a variable. So you go through each kind of start with zero, right? Initial value will be zero, and then you use a loop, iteration and then you just add that elements, the numbers in that array, to that sum, So that will give you the total kind of the sum of that array. So this is kind of the loop approach. But now I'd like you to think about a divide and a conquer approach. what I'm going to do, to use a divide or conquer approach to solve that problem, Okay, Okay Now, based on our description of divide or conquer approach, the first, you need to break down a problem into two or more sub-problems of the same type. Okay, Now let's look at how I'm going to divide that problem into sub-problems, Because I'm going to have that array. I don't know how to solve that. to sum it up: right, You are not going to use the iteration, So, but I'm going to divide it into a sub-problem. What I'm going to divide, I'm going to split into two half. It's more like you slice your loaf right. Going back to the first example I told you I'm going to kind of split that array into the half left half and the right half. It will look like this: And then now I start with array of eight elements. Now I end up kind of after first the division, I end up two arrays, one with four items, another with four items as well. But if you look at that one, the left one, can I sum it up? I still need to use recur- the iteration right. I still need to use for loop, go through each elements in the array and add them up. So that means I haven't kind of get to the simplest kind of the solution yet. So I have kind of the keep- I need to keep dividing my array. So now, if I do the same, well, for the left array, I split into two kind of two of two, and right array two of two. So now I end up at four kind of arrays. Each of them contains two items. So now, if you look at these two items, can I do the sum up? I still need to do kind of somehow iteration right First and the second Okay. So now I still need to keep doing it. So what I mean is you can keep kind of dividing array again. Now, finally, I end up with eight arrays. Each array contains one item. Now if I ask you, if you have array that only contains one item, are you able to tell me how are you going to do the sum? So if I give you array has only one item, what is sum of that array? What is the sum of Just that item? right, The first item. So that means, without actually iterating through your array, I just return that item. For example, I just return the 3466.. So that means I already know how to solve that problem, The simplest. So this is the kind of simplest, the solution. So next, what are you going to do? You know, kind of you'll be able to solve the simplest kind of the problem. What are you going to do? You're going to combine all the solutions, right, You combine all these solutions to the smaller problems. that will give you the solution to the bigger problem And then the original problem. what are you going to do? So this is the kind of the next kind of step, right, You're going to combine all these sub-problems to give solution to the previous kind of the problem. Okay, Now let's look at how you combine them. So I know now I'm going to return the 3466.. So combination: we could just add them together right. So now I add 34 and 66 together gave me 100. So this all kind of gave me the solution for that, To combine that solution at that level And then I carry it on and eventually it will give you the solution of the original problem. You just sum up all the items. So this is really kind of so hard to understand. I think at that point, But after we're talking about today and on Thursday and then we look at merge sort on the Friday, you will actually understand what it means. Okay, Now I'm going to actually write a method, exactly describe what actually I gave it to you. now I'm going to implement it. How are you going to implement that solution? So I'm going to use recursive function, recursive method, actually to just implement a sum up. The method just gave you what I just described. Okay, Divide and conquer approach. So this will be the name of my method. So that method is going to sum up this array. So this is just a kind of input right Now, the first I'm going to check. So if array only have one item, so I know how to do it right. So I'm going to return. So this will be my answer, right? So you think about the last kind of step. right, I divided all the array. Now it becomes kind of the eight arrays. Each array only contains one item, So that is kind of return that array. Otherwise, if that array has more than one item in the array, I'm going to divide it right. So I'm going to find the middle point. So this just give me the middle point. I'm going to slice it into left array and the right array. So this is nothing special about that method. The method just says if this is original array, I'm going to slice it from the middle. So this will be the left array and the right array. okay, So I haven't finished the implementation. okay, Can anyone actually tell me at that point what will be the next statement? There's only one line of code. I'm going to finish my implementation. Anyone can just look at my code. now. I already have a method. You have to use recursive function, right? So if I ask you now, could you just write one line of code that will give me the finished implementation of some array, just based on what I described so far. Yes, call the summary right And on what? And yes, Right away, And Add them together, Right, Yes, I'm going to sum array the left array, I'm going to sum the right away, again right, And then add them together. So that's the solution. So, if you look at that solution, actually it's quite simple, But that's recursive, That's a recursion, Okay. So now I gave you an example. I divide it, kind of that array, I split that array in the middle point, right? So it doesn't mean that I have to always split my array in the middle point. Actually, you can do the like. I want to split my array into, kind of the three proportions, or four portions, Or four portions. That's fine as well, right? So what you need to do, you just need to find one third point, Okay, One third point, Another two third point, And then you have left array, middle kind of array in the middle, and right array And you do the slice And then you do the kind of just add them together. Don't worry about this recursion, right? That's why we want to spend more time. So I'm going to help you to understand actually what's going on. So that will give you the solution. Okay, Now you've. So now, So, after this, so we're going to actually, I think, in your exam and then when we design all these algorithms, we actually we need to write recursive functions. So this is what we call the recursive function. So if you look at recursive function, it's just the function actually call itself, right? So because you have the summary, So this is actually the first time I'm not sure whether you have heard of recursion or recursive function. So if you look at that- so I just go back to that- So you actually have a method called the method itself. So you have summary, right, And then you inside in the summary implementation, actually you call the summary But your data is different, right? So the first one, you call the whole array, But this time actually your problem comes smaller. So this, when you call this summary again, actually your problem comes smaller because you're only dealing with this half right. So this is kind of this half Okay. So this is pretty much the recursive function. So it's a function called self, But every time your data or your problem dealing with is kind of the smaller Okay. so for the recursive function or recursion, so you so this just kind of- we already talked about- divide the problem into smaller examples of same problem. If solution is a method, we may call the method again, kind of call the method again, But for the smaller problem. so in this case, the smaller problem, just the kind of the, the kind of small, just one proportion of the array, right, It's a small problem, Okay. And so these are something I really like you to remember, If you want. if you write recursive function, there are two cases you need to dealing with. One we called the base case, So just solve a small problem, the trivial problem. Another recursive case just solves a larger problem, on the assumption you can solve a smaller problem. So in this case, so if you look at some array example, the base case is our smallest problem, right It? just when you only have one array, only have one item in the array. So this will be your base case. So later you'll understand why we need base case. And then we have a recursive case. So if you write the recursive function, the first thing probably you need to write is just have these kind of comments: right, Base case and the recursive case. And then you'll have to think about what will be your base case, What will be the recursive case. I'm going to show you more examples. Okay, Now we kind of gave, so this just gave a really really kind of general introduction about divide-conquer and what is recursion and what is recursive method. So I already used some examples. So the next I'm going to show you three examples And on Thursday I'm going to show you more examples, Okay, So our first example is calculating factorial number. So factorial- if you already learned that how you do the factorial in high school, right, Probably, Probably in high school. So factorial of n is defined like this: It's n multiplied and minus one multiplied and minus two, et cetera, to n. Now, if I ask you to write a method to compute factorial of n, but of course you are going to write recursive function, Okay, You are not going to write iterative, You can do, you can do that using iterative kind of approach. but now we're going to talk about recursive, right? So that means you are going to write recursive method to do that. So, but of course, the first thing you need, so when you're dealing with recursive recursion, the first thing you need to think about- how are you going to divide the problem into smaller examples of the same problem? Okay, What is the kind of the smaller problem. So now, if we look at how to calculate factorial, so this is your definition, right? Factorial definition. So if you look at that proportion, so which is just the factorial of n minus one, Okay, So if you look at that, it's factorial of minus one, So this will be a factorial of n minus two, right? So if you rewrite that factorial, the formula, it will become n multiply n minus one, factorial. Okay, So now this is our smaller problem, right? So this is actually n minus one is also a smaller problem Used to. we need to solve problem of n. Now we only need to solve the problem of n minus one, Okay, So now let's look at how actually you'll be able to implement it. if I already gave you that definition, And so that will be so, if we have a method like factorial n, so if we just based on that formula, the mathematical formula, right, You can just do them n multiply, because we already have a method to calculate factorial. but this time we're going to calculate n minus one because we're going to call that function the factorial. on a smaller problem: Now we're only dealing with n minus one, Okay, Now let's just try a simple factorial of two. Okay, Let's just do the factorial of two. So we just go through that method using the n equal to two. Okay, So now if n equals to two, so just go through the method, right? So there's nothing about nothing special about that method, just a method. If you think about just a method, Now we have n equal to two, so if we go inside the method, so that method is going to have two multiply factorial, because now n minus two is two minus one, right? So that's what we call that method. Of course we haven't finished that method yet, right? So because now it's become two minus one, it's actually factorial of one. It will look like this, right? So that means we haven't reached end. We have to kind of going to go. we're going to call the factorial of one. So now if we call the factorial of one, so that means n is equal to one, So it will be one multiply factorial, one minus one. So that will become factorial of zero. We haven't finished, right? Because there's no return. actually, let us finish. So now we have a factor of zero become zero, multiplying factorial of n minus one. So this just kind of carries on, right, And then until something happens, okay. So let's see what would happen if we just do something like this. So that's the method I just implemented. I just showed you that factorial, okay, And then I tried the factorial of two, So let's just run it. So this is Stack Overflow exception. So we're talking about a Stack Overflow website, right, And so actually, the Stack Flow website, when they first name that website, it's actually using the Stack Flow exception to name their kind of the website. It's called Stack Flow. So what happened here? So if you look at it, so can anyone tell me? so what happened here, Why it has that exception? So we talk about when you write recursive function, right, We talk about the base case and recursive case. So what is missing here? if you look at that method, We talk about we need kind of two cases. We need to dealing with two cases, right, For the recursive function. Now we have recursive case, right, So recursive case means that we call that the method again. But what is the base case? So what is the factorial of n- zero? Do you know what is factorial of zero? Do you still remember? So if n equals to zero, so what you are going to return, What is the factorial of zero And what is the factorial of one? So that means you are going to return one, So this will be our base case. Okay, So this is our recursive case. So if we run it again, it's going to return one, two, I think it's going to return. Okay, So that's in the return statement. But if we just do the calculation, it's going to return two. Okay, So now let's go back to our slides. Okay, So the reason I want to show this, I just want to kind of point out you have to write the base case, right, Otherwise you're going to have stack overflow exception. I haven't really explained what the stack overflow is. Okay, Now, once we have that base case, what it will look like. So if you go back to that function again, right. So now, if we have n equals to two, if we call the factorial of two, so the two multiply factorial of two minus one. So two minus one will become factorial one, right? So once we have factorial one, so we're going to call the factorial one. So now n is equal to one, So we're going to return one. So that means this is going to return one. So this will become one, And eventually it's going to return two. But if you look at previously, because we don't have base case, right. That kind of the recursive call it- just carries on and on and on until your stack memory is full. Once your stack memory is full and then it's going to your system, the system is going to throw the stack overflow exception because it's full, right, Okay? So we'll come back to our stack overflow problem on Thursday in more detail. So if you think about last time I talked about last week, we talked about the stack stack free, right, We talked about the core stack. So the stack memory is actually stored information about all the active method. So for each method they're going to have a stack frame created and pushed on top of the stack. So it's the same thing. We're going to look at how actually recursive function is represented on the stack memory. So you would understand why the stack kind of the overflow happens. But I'll just leave that kind of till Thursday. But we'll just go through other examples today. Okay, For the factorial solution, recursive solution, we also have iterative solution. For any, pretty much any kind of recursive solution you can write iterative solution. It's just sometimes recursive solution. it's much simpler, much easier to write- actually- I'm going to show you example- than iterative solution, Okay, So the next example is calculating Fibonacci numbers. Hopefully you're familiar with how to calculate Fibonacci numbers. So, for Fibonacci numbers, you start with two initial values: 0 and 1.. And then the third one, so this one become the first two, the addition of the first two. right? So you add 0, 1, give you 1.. And then you add 1 and 1, give you 2.. You add 1 and 2, give you 3,, et cetera. It's mathematically, it's defined like this. So it's mathematically defined as n, with initial values the 0 and 1.. So that is, these two are the initial values. Now, if I ask you, so this just gave you the factorial of 2, right, So it would be the 1,, et cetera. Now, if I ask you to write iterative solution, so it will look like this- It's not actually difficult to do if I ask you to do it. So you're going to maintain the two pointers. So you're going to remember these first two values, right, You're going to. so this will be. you're going to remember the M1 and M2.. So they're just the two, kind of. you're going to remember these two values And so this one will be the one you're going to calculate. Okay, And then so you start with two pointers like this, two values like this: And for the full loop. so this is the full loop And you just kind of slide. you're going to slide one item at a time, So that means the next time you're going to slice it. right Now you're calculating, so you're going to calculate these two And then for the next kind of full loop, you're going to slide again and et cetera, and until you meet your end. So this is the kind of you decide by end. Okay, So this actually is not that difficult if I ask you to do it. But today we're going to look at recursive solution, Okay Now. so, as I already mentioned, right For the recursive solution. so you need to think about the base case and recursive case. Now, if I ask you what will be the base case, Can you give me some kind of ideas? what will be the base case? Somehow they showed you what is the base case for the factorial right Factorial of the base case. if n is equal to 0 or n equal to 1, you're going to return 1.. So now you tell me what will be the base case in this case. The simplest case is, somehow we have this kind of initial values, right, The base case. So what will be the base case. So that means if n equal to 1, we're going to. so if n equal to 1, we're going to return 0, right. So if n equal to 1 to 2, we're going to. so this will be: n equal to 0, n equal to 1.. So we're going to return n. So this is kind of n equal to 0.. So n equal to 1, right. n equal to 0, and then n equal to 1, we're going to return n. Because if n equal to 0, we return 0, n equal to 1, we return 1.. So that means: so this is just a simple form. So if you write it, if you want to write it separate, that will be okay. So that means if n equal to 0, return 0. If n equal to 1, return 1.. But if you put them together, it just kind of: if n equal to 0 or n equal to 1, it just return n. So it's just kind of a more compact form. So what will be the recursive case? So if for the recursive case, we just look at that formula, right, It's defined like this: So we already have Fibonacci function defined. So this is a means recursive, So we're going to calculate n minus 1.. So we already have that function ready. And then we plus the factorial Fibonacci, n minus 2.. So this is just our calculation, right? We just follow the mathematical solution. So that is actually very simple. So if you compare our iteration, so this is our iterative kind of the solution, So this is the recursive solution. So the recursive solution is actually. it's quite simple. Let's get to the point. It's actually matching the mathematical definition, right? It's easy, very easy to understand. Actually, if you look at that recursive information compared to iterative solution, it's actually easy to understand. But actually there's a catch. So I'll come back to that on Thursday For that one. for if you call Fibonacci recursive, when n doesn't have to be really really large, When n, I think, is get to like 40-ish, it might take hours to finish. Even the n is to get to probably 40. I can't remember the exact number, probably 30-something. It will take hours to finish And I will explain why that happens. The answers say okay. So that means we're going to have a need to have a kind of more practical implementation, Okay, The next example is graphics: flood and fill. I'm going to show you what I mean for that one. I just run it first. So you are going to, if I ask you to write a C-sharp. the program allows me to do that. You think about your solution, okay. So this C-sharp, the program is allowing me to do the first, to draw. So this is the kind of draw I'm going to draw. So it's just any shape, right, I just draw any shape but have to be kind of the field has to be, And then I do a flood. So you're going to write a C-sharp solution and allow me to do that. You think about how are you going to do that? okay, And I can. it's just very simple. I'm not sure whether actually I can draw again, Oh, Okay, I just. I think eventually, it's just a feel, it's going to fill the whole kind of the form. Okay, If I let it around, but I don't have time to let it finish, Otherwise it's going to finish the whole form, Okay, Okay. So now, if I ask you to think about it, how many lines of code actually you need to write to implement kind of application like this? Okay, But so this is the actual code: during the flood and fill. So that is actually the flood and fill recursive case. So the X and Y just kind of one pixel. So this is the actual code. So how many code are there? One, two, three, four, five, six, I don't know, Probably 10, more than 10.. And then this is kind of: you start, you're using a thread to start the drawing, Otherwise you wouldn't be able to interact with the form at all. So I'm going to talk about shortly. But so this is actually the code. allow you to do that, just to kind of you draw, that Draw is kind of separate, but you just do the flood and fill. So but if you so I'm going to come back to the code, actual code on my slides, And then I'm going to explain to you how that works. Okay, so this is basically the idea of flood and fill. This is just the code itself. So if you look at, so the line I just draw, right, it is has to be a closed kind of line, closed shape. So if you just imagine, this is kind of the line, just draw each cell. So each cell it's just a pixel. It's just a pixel on the image, So each cell, it's just a pixel. Okay, So for some. so on the boundaries, right, I draw that kind of the line, The boundaries will look like this, because the boundaries is already in black. It's already in black. So now, if we look at the, so each x and y is going to represent a cell, a pixel on the, on that, the graph, the, the image. So each x and y, for example, so this will be the x and y, So the x will be the x will be two. I think Y will be zero for for that cell, Okay Now. so now if we look at the code, right, the first code is just: I just use that bitmap, get pixel. We ought to talk about bitmap function, I think, in one one to get that, the color of that. So, for example, I want to get that color, I get, I could get any kind of color, So, but I'm only interested in the color within that boundary, right within that boundary. So if that x, y, if I get that color, so these are the cross, right, if I x and y happen to here, right, then I use a color to get its color. Now, if I check it right, if it's r, red, green and blue, if they're all zero, so that means it's already black, So I don't need to do anything at all about that pixel. So, if it's just happened on the boundary, so that means if I just click, click it. it's just click on the boundary, so that's, nothing happens. Otherwise, I'm going to do the recursive case. Now, if you look at recursive case, right, I call the flop and the fill again, but in this case I look at the left cell of that one, So I'm going to show you that. So I'm going to look at recursive case. So this is kind of the base case, if I kind of so, for that one it's already in black, so I'm going to return, so this will be the base case. So now, if I add that pixel- so this is the kind of recursive case, right, what I'm going to do- I'm going to set that. so this is the kind of the code- I'm going to set that pixel to black color. so this is the one. so this one does. okay, I'm going to set it to black, And then I'm going to call the recursive function. I'm going to call recursive function. So that is, gave me the cell on the left, so this will give me that cell actually. And then gave me the cell on the right, So that gave me the cell on the top and that gave me the cell on the bottom. So I'm going to. so, yes, you are starting from here. right, I finished that one, I'm going to paint it in black and then I'm going to paint the left cell and after I finish, I'm going to paint the right cell and the top and the bottom. So this just go back to recursive. Now I'd like you to also pay attention on this tree. right, I'm starting from here And then I'm going to call the. so this one. okay, So it's not in red, right, I'm going to make it red. I'm going to look at its left again. right, So I'm going to look at its left, right, top and bottom. So now you can look at I'm building that tree, right, If you look at I'm building that tree And then I'm going to work on that, It's already in black, so I don't need to worry about it. right, I'm going to return. So I'm going to return. So that means I don't need to carry on. right, I'm going to return. So this is a tree. I'm going to work on that one. So that is kind of already in black. I'm going to look at its top, the top one. So the top one is going to look at its top, left, right, top again. So this will be kind of recursive, kind of carries on, And then once I finish that, I'm kind of going back to that, I'm going to look at that one. And once I finish- right, only finish that one- I'm going kind of going back. See, if you look at it, I'm branching it. If I finish every kind of at the bottom, I'm going back, I'm going back, I'm going to look at that one, right, So I'm going to look at that one, I'm going to look at the one And then carry on the same thing again: right, The left and right, top and bottom, left and right bottom. So this is the kind of recursive case. okay, Now if I ask you to actually think about how you're going to write iterative solution, probably it will take you days to do it And eventually you are going to build a tree like this actually Your solution, your iterative solution. you're going to use a tree structure actually to build a tree like this to do the implementation. Okay, so this example I just want to show you: Sometimes iterative solution will give you a very easy, simple, clean solution. But there's always a catch, right, if you have this kind of simple solution, But there's always a catch. So that's something we're going to talk about on Thursday. Okay, so we've still got four kind of minutes I want to show you. I want to just look at that mystery function. So I'd like you to think about what that mystery function does. So this will be one of the example, the questions. So you're going to have questions like this in your final exam. So you're going to, well, give you mystery function, You're going to look at code And you're going to tell me what that actually mystery function does. So now you can look at that mystery function. Can anyone actually tell me what that function does? Just set out the single partage. Hopefully you already know the answer. Okay, Has anyone all had the answer? What Can you add all the numbers together? Yes, It's just to sum up all the numbers of the array. Okay, Move that first, right, And then you carry on the rest. So you move that line And then you calculate that Eventually. just add all the numbers together, Yes, Okay. So how about that one Mystery tool? So why? that will return if I run it. Okay, Okay, Okay. So how about that one? Thank you, Yes, the same thing, right, it's just like the sum up array, right? So this is kind of the same implementation as that one. So that summary is the same implementation as the one I kind of showed you at the kind of at the beginning of the lecture. Okay, So that's for today. It's- I know it's quite a lot. Hopefully on Thursday I'm going to show you how these recursive functions is represented on the stack. We'll give you a more clear of how that works right on Thursday. So let's see, We'll give you a moment, Thank you, Thank you.
</p>
</body>
</html>
    